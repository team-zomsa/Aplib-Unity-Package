<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Aplib.Core</name>
    </assembly>
    <members>
        <member name="T:Aplib.Core.Agents.BdiAgent`1">
            <summary>
            Represents an agent that performs actions based on goals and beliefs.
            </summary>
        </member>
        <member name="F:Aplib.Core.Agents.BdiAgent`1._beliefSet">
            <summary>
            Gets the belief set of the agent.
            </summary>
        </member>
        <member name="F:Aplib.Core.Agents.BdiAgent`1._desireSet">
            <summary>
            Gets the desire of the agent.
            </summary>
            <remarks>
            The desire contains all goal structures and the current goal.
            </remarks>
        </member>
        <member name="P:Aplib.Core.Agents.BdiAgent`1.Status">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Agents.BdiAgent`1.#ctor(`0,Aplib.Core.Desire.DesireSets.IDesireSet{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Agents.BdiAgent`1" /> class,
            from a given set of beliefs and desires.
            </summary>
            <param name="beliefSet">The belief set of the agent.</param>
            <param name="desireSet">The desire set of the agent.</param>
        </member>
        <member name="M:Aplib.Core.Agents.BdiAgent`1.Update">
            <summary>
            Performs a single BDI cycle, in which the agent updates its beliefs, selects a concrete goal,
            chooses a concrete action to achieve the selected goal, and executes the chosen action.
            </summary>
            <remarks>This method will get called for every frame of the game.</remarks>
        </member>
        <member name="T:Aplib.Core.Agents.IAgent">
            <summary>
            Defines a testing agent that can be updated for every frame of the game.
            </summary>
        </member>
        <member name="M:Aplib.Core.Agents.IAgent.Update">
            <summary>
            Updates the agent's beliefs, desires, and intentions.
            </summary>
            <remarks>This method will get called for every frame of the game.</remarks>
        </member>
        <member name="T:Aplib.Core.Belief.BeliefSets.BeliefSet">
            <summary>
            This class can be inherited to define a set of beliefs for an agent.
            All <i>public fields</i> defined in the inheriting class that implement <see cref="T:Aplib.Core.Belief.Beliefs.IBelief" />
            are automatically updated when calling <see cref="M:Aplib.Core.Belief.BeliefSets.BeliefSet.UpdateBeliefs" />.
            </summary>
        </member>
        <member name="F:Aplib.Core.Belief.BeliefSets.BeliefSet._beliefs">
            <summary>
            An array storing all <i>public fields</i> of type <see cref="T:Aplib.Core.Belief.Beliefs.IBelief" /> that are defined in the inheriting
            class.
            </summary>
        </member>
        <member name="M:Aplib.Core.Belief.BeliefSets.BeliefSet.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Belief.BeliefSets.BeliefSet"/> class and stores all <i>public fields</i> defined
            in the inheriting class that implement <see cref="T:Aplib.Core.Belief.Beliefs.IBelief" /> in an array.
            All public <see cref="T:Aplib.Core.Belief.Beliefs.IBelief" /> fields are then automatically updated when calling
            <see cref="M:Aplib.Core.Belief.BeliefSets.BeliefSet.UpdateBeliefs" />.
            </summary>
        </member>
        <member name="M:Aplib.Core.Belief.BeliefSets.BeliefSet.UpdateBeliefs">
            <summary>
            Updates all objects that implement <see cref="T:Aplib.Core.Belief.Beliefs.IBelief"/> and that are defined as <i>public fields</i> in the
            inheriting class.
            </summary>
        </member>
        <member name="T:Aplib.Core.Belief.BeliefSets.IBeliefSet">
            <summary>
            A belief set defines the beliefs of an agent.
            </summary>
        </member>
        <member name="M:Aplib.Core.Belief.BeliefSets.IBeliefSet.UpdateBeliefs">
            <summary>
            Updates all beliefs in the belief set.
            </summary>
        </member>
        <member name="T:Aplib.Core.Belief.Beliefs.Belief`2">
            <summary>
            Represents the agent's belief of a single object.
            Some <i>object reference</i> is used to generate/update an <i>observation</i>
            (i.e., some information about the game state as perceived by an agent).
            </summary>
            <remarks>
            This class supports implicit conversion to <typeparamref name="TObservation" />.
            </remarks>
            <typeparam name="TReference">
            The type of the object reference used to generate/update the observation.
            This <i>must</i> be a reference type,
            be aware that this is not enforced by the type checker if <typeparamref name="TReference" /> is an interface.
            </typeparam>
            <typeparam name="TObservation">The type of the observation that the belief represents.</typeparam>
        </member>
        <member name="F:Aplib.Core.Belief.Beliefs.Belief`2._reference">
            <summary>
            The object reference used to generate/update the observation.
            </summary>
        </member>
        <member name="F:Aplib.Core.Belief.Beliefs.Belief`2._getObservationFromReference">
            <summary>
            A function that takes an object reference and generates/updates an observation.
            </summary>
        </member>
        <member name="F:Aplib.Core.Belief.Beliefs.Belief`2._shouldUpdate">
            <summary>
            A condition on when the observation should be updated. Takes the object reference
            of the belief as a parameter for the predicate.
            </summary>
        </member>
        <member name="P:Aplib.Core.Belief.Beliefs.Belief`2.Metadata">
            <summary>
            Gets the metadata of the Belief.
            </summary>
            <remark>
            This metadata may be useful for debugging or logging.
            </remark>
        </member>
        <member name="P:Aplib.Core.Belief.Beliefs.Belief`2.Observation">
            <summary>
            The observation represented by the belief
            (i.e., some information about the game state as perceived by an agent).
            </summary>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.Belief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1},System.Predicate{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Belief.Beliefs.Belief`2" /> class with an object
            reference, a function to generate/update the observation using the object reference,
            and optionally a condition on when the observation should be updated.
            </summary>
            <param name="metadata">
            Optional metadata about this belief, used to quickly display the goal in several contexts.
            If omitted, default metadata will be used.
            </param>
            <param name="reference">
            The object reference used to generate/update the observation. This <i>must</i> be a reference type, be aware
            that this is not enforced by the type checker if <typeparamref name="TReference"/> is an interface.
            </param>
            <param name="getObservationFromReference">
            A function that takes an object reference and generates/updates an observation.
            </param>
            <param name="shouldUpdate">
            An optional condition on when the observation should be updated.
            Takes the object reference of the belief as a parameter for the predicate.
            If omitted, the belief will always update.
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="reference" /> is not a reference type.
            </exception>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.Belief`2.#ctor(`0,System.Func{`0,`1},System.Predicate{`0})">
            <inheritdoc
                cref="M:Aplib.Core.Belief.Beliefs.Belief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1},System.Predicate{`0})" />
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.Belief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1})">
            <inheritdoc
                cref="M:Aplib.Core.Belief.Beliefs.Belief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1},System.Predicate{`0})" />
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.Belief`2.#ctor(`0,System.Func{`0,`1})">
            <inheritdoc
                cref="M:Aplib.Core.Belief.Beliefs.Belief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1},System.Predicate{`0})" />
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.Belief`2.op_Implicit(Aplib.Core.Belief.Beliefs.Belief{`0,`1})~`1">
            <summary>
            Implicit conversion operator to allow a <see cref="T:Aplib.Core.Belief.Beliefs.Belief`2" /> object
            to be used where a <typeparamref name="TObservation" /> is expected.
            </summary>
            <param name="belief">The <see cref="T:Aplib.Core.Belief.Beliefs.Belief`2" /> object to convert.</param>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.Belief`2.UpdateBelief">
            <summary>
            Generates/updates the observation if the <c>shouldUpdate</c> condition is satisfied.
            The observation is then updated by calling the <c>getObservationFromReference</c> function.
            </summary>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.Belief`2.UpdateObservation">
            <summary>
            Generates/updates the observation.
            </summary>
        </member>
        <member name="T:Aplib.Core.Belief.Beliefs.IBelief">
            <summary>
            A belief represents/encapsulates an observation,
            i.e., information about the game state as perceived by an agent.
            </summary>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.IBelief.UpdateBelief">
            <summary>
            Updates the belief based on information about the game state.
            </summary>
        </member>
        <member name="T:Aplib.Core.Belief.Beliefs.ListBelief`2">
            <summary>
            A convenience variant of <see cref="T:Aplib.Core.Belief.Beliefs.Belief`2" /> to track multiple references in one
            belief. Both the collection storing the references and the references themselves can be changed after the
            <see cref="T:Aplib.Core.Belief.Beliefs.ListBelief`2" /> has been created.
            </summary>
            <remarks>
            A <see cref="T:Aplib.Core.Belief.Beliefs.ListBelief`2" /> can be implicitly converted to a
            <see cref="T:System.Collections.Generic.List`1" />, which will have the same size as the reference collection the last time that
            <see cref="M:Aplib.Core.Belief.Beliefs.Belief`2.UpdateBelief" /> was called, and contain the observation results for
            each element in the collection.
            </remarks>
            <typeparam name="TReference">
            The type of the object references used to generate/update the observation.
            </typeparam>
            <typeparam name="TObservation">The type of the observations that the belief represents.</typeparam>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.ListBelief`2.#ctor(Aplib.Core.Metadata,System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1},System.Predicate{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Belief.Beliefs.ListBelief`2" /> class from an object
            reference collection, a function to generate an observation from an object reference, and optionally an
            update guard.
            </summary>
            <param name="metadata">
            Metadata about this Belief, used to quickly display the goal in several contexts.
            </param>
            <param name="references">
            The collection of reference objects. The underlying type implementing <see cref="T:System.Collections.Generic.IEnumerable`1" />
            <i>must</i> be a reference type, note that this is not enforced by C#.
            </param>
            <param name="getObservationFromReference">
            A function that takes an object reference and generates an observation.
            </param>
            <param name="shouldUpdate">
            A condition on when the observation should be updated. Takes the object references enumerable
            of the belief as a parameter for the predicate.
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="references"/> is not a reference type.
            </exception>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.ListBelief`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1},System.Predicate{System.Collections.Generic.IEnumerable{`0}})">
            <inheritdoc
                cref="M:Aplib.Core.Belief.Beliefs.ListBelief`2.#ctor(Aplib.Core.Metadata,System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1},System.Predicate{System.Collections.Generic.IEnumerable{`0}})"/>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.ListBelief`2.#ctor(Aplib.Core.Metadata,System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1})">
            <inheritdoc
                cref="M:Aplib.Core.Belief.Beliefs.ListBelief`2.#ctor(Aplib.Core.Metadata,System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1},System.Predicate{System.Collections.Generic.IEnumerable{`0}})" />
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.ListBelief`2.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1})">
            <inheritdoc
                cref="M:Aplib.Core.Belief.Beliefs.ListBelief`2.#ctor(Aplib.Core.Metadata,System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1},System.Predicate{System.Collections.Generic.IEnumerable{`0}})" />
        </member>
        <member name="T:Aplib.Core.Belief.Beliefs.MemoryBelief`2">
            <summary>
            The <see cref="T:Aplib.Core.Belief.Beliefs.MemoryBelief`2"/> class represents the agent's belief of a single object,
            but with additional "memory" of previous observations.
            Some <i>object reference</i> is used to generate/update an <i>observation</i>
            (i.e., some piece of information on the game state as perceived by an agent).
            This belief also stores a limited amount of previous observations in memory.
            </summary>
            <remarks>
            It supports implicit conversion to <typeparamref name="TObservation"/>.
            </remarks>
            <typeparam name="TReference">
            The type of the reference used to generate/update the observation. This <i>must</i> be a reference type, be aware that
            this is not enforced by C# if <typeparamref name="TReference"/> is an interface.
            </typeparam>
            <typeparam name="TObservation">The type of the observation the belief represents.</typeparam>
        </member>
        <member name="F:Aplib.Core.Belief.Beliefs.MemoryBelief`2._memorizedObservations">
            <summary>
            A "memorized" resource, from the last time the belief was updated.
            </summary>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.MemoryBelief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1},System.Int32,System.Predicate{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Belief.Beliefs.MemoryBelief`2"/> class with an object
            reference, a function to generate/update the observation using the object reference, and a condition on when
            the observation should be updated. Also initializes the memory array with a specified number of slots.
            </summary>
            <param name="metadata">
            Metadata about this Belief, used to quickly display the goal in several contexts.
            </param>
            <param name="reference">
            The reference used to generate/update the observation. This <i>must</i> be a reference type, be aware that
            this is not enforced by C# if <typeparamref name="TReference"/> is an interface.
            </param>
            <param name="getObservationFromReference">
            A function that takes a reference and generates/updates a observation.
            </param>
            <param name="framesToRemember">The number of frames to remember back.</param>
            <param name="shouldUpdate">
            A condition on when the observation should be updated. Takes the object reference
            of the belief as a parameter for the predicate.
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="reference"/> is not a reference type.
            </exception>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.MemoryBelief`2.#ctor(`0,System.Func{`0,`1},System.Int32,System.Predicate{`0})">
            <inheritdoc
                cref="M:Aplib.Core.Belief.Beliefs.MemoryBelief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1},System.Int32,System.Predicate{`0})"/>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.MemoryBelief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1},System.Int32)">
            <inheritdoc
                cref="M:Aplib.Core.Belief.Beliefs.MemoryBelief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1},System.Int32,System.Predicate{`0})" />
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.MemoryBelief`2.#ctor(`0,System.Func{`0,`1},System.Int32)">
            <inheritdoc
                cref="M:Aplib.Core.Belief.Beliefs.MemoryBelief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1},System.Int32,System.Predicate{`0})" />
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.MemoryBelief`2.UpdateBelief">
            <summary>
            Generates/updates the observation.
            Also stores the previous observation in memory.
            </summary>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.MemoryBelief`2.GetMostRecentMemory">
            <summary>
            Gets the most recently memorized observation.
            </summary>
            <returns> The most recent memory of the observation.</returns>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.MemoryBelief`2.GetMemoryAt(System.Int32,System.Boolean)">
            <summary>
            Gets the memorized observation at a specific index.
            A higher index means a memory further back in time.
            </summary>
            <returns>The memory of the observation at the specified index.</returns>
            <param name="index">The index of the memory to get.</param>
            <param name="clamp">If true, the index will be clamped between 0 and the last memory index.</param>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.MemoryBelief`2.GetAllMemories">
            <summary>
            Gets all the memorized observations.
            The first element is the newest memory.
            </summary>
            <returns> An array of all the memorized observations.</returns>
        </member>
        <member name="T:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2">
            <summary>
            The <see cref="T:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2"/> class represents the agent's belief of a single object,
            but with additional "memory" of previous observations.
            These observations are sampled at a fixed rate.
            Some <i>object reference</i> is used to generate/update an <i>observation</i>
            (i.e., some piece of information on the game state as perceived by an agent).
            This belief also stores a limited amount of previous observation samples in memory.
            Optionally, the belief can always store the most recent observation, regardless of the sample rate.
            </summary>
            <remarks>
            It supports implicit conversion to <typeparamref name="TObservation"/>.
            </remarks>
            <typeparam name="TReference">
            The type of the reference used to generate/update the observation. This <i>must</i> be a reference type, be
            aware that this is not enforced by C# if <typeparamref name="TReference"/> is an interface.
            </typeparam>
            <typeparam name="TObservation">The type of the observation the belief represents.</typeparam>
        </member>
        <member name="F:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2._sampleInterval">
            <summary>
            The sample interval of the memory (inverse of the sample rate).
            One observation memory (i.e., snapshot) is stored every <see cref="F:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2._sampleInterval"/>-th cycle.
            </summary>
        </member>
        <member name="F:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2._updateMode">
            <summary>
            Specifies how this sampled memory belief should be updated.
            </summary>
        </member>
        <member name="P:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2.ModuloCounter">
            <summary>
            The number of cycles that have passed since the last memory sample was stored.
            </summary>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1},System.Int32,Aplib.Core.Belief.Beliefs.UpdateMode,System.Int32,System.Predicate{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2"/> class with an
            object reference, a function to generate/update the observation using the object reference, and a condition
            on when the observation should be updated. This belief also stores a limited amount of previous observation
            samples in memory.
            Optionally, the belief can always store the most recent observation, regardless of the sample rate.
            </summary>
            <param name="metadata">
            Metadata about this goal, used to quickly display the goal in several contexts.
            </param>
            <param name="reference">
            The reference used to generate/update the observation. This <i>must</i> be a reference type.
            </param>
            <param name="getObservationFromReference">
            A function that takes a reference and generates/updates an observation.
            </param>
            <param name="sampleInterval">
            The sample interval of the memory.
            One observation memory (i.e., snapshot) is stored every <c>sampleInterval</c>-th cycle.
            </param>
            <param name="updateMode">Specifies how this sampled memory belief should be updated.</param>
            <param name="framesToRemember">The number of frames to remember back.</param>
            <param name="shouldUpdate">
            A condition on when the observation should be updated. Takes the object reference
            of the belief as a parameter for the predicate.
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown when <paramref name="reference"/> is not a reference type.
            </exception>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2.#ctor(`0,System.Func{`0,`1},System.Int32,Aplib.Core.Belief.Beliefs.UpdateMode,System.Int32,System.Predicate{`0})">
            <inheritdoc
                cref="M:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1},System.Int32,Aplib.Core.Belief.Beliefs.UpdateMode,System.Int32,System.Predicate{`0})" />
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1},System.Int32,Aplib.Core.Belief.Beliefs.UpdateMode,System.Int32)">
            <inheritdoc
                cref="M:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1},System.Int32,Aplib.Core.Belief.Beliefs.UpdateMode,System.Int32,System.Predicate{`0})" />
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2.#ctor(`0,System.Func{`0,`1},System.Int32,Aplib.Core.Belief.Beliefs.UpdateMode,System.Int32)">
            <inheritdoc
                cref="M:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2.#ctor(Aplib.Core.Metadata,`0,System.Func{`0,`1},System.Int32,Aplib.Core.Belief.Beliefs.UpdateMode,System.Int32,System.Predicate{`0})" />
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2.ShouldSampleMemory">
            <summary>
            Determines whether the memory should be sampled.
            One observation memory (i.e., snapshot) is stored every <c>sampleInterval</c>-th cycle.
            </summary>
            <returns>Whether a memory sample should be stored in the current cycle.</returns>
        </member>
        <member name="M:Aplib.Core.Belief.Beliefs.SampledMemoryBelief`2.UpdateBelief">
            <summary>
            Generates/updates the observation if applicable.
            Also stores the previous observation in memory every <c>sampleInterval</c>-th cycle.
            </summary>
        </member>
        <member name="T:Aplib.Core.Belief.Beliefs.UpdateMode">
            <summary>
            Specifies the update mode of a sampled memory belief.
            </summary>
        </member>
        <member name="F:Aplib.Core.Belief.Beliefs.UpdateMode.AlwaysUpdate">
            <summary>
            Update the observation every cycle.
            </summary>
        </member>
        <member name="F:Aplib.Core.Belief.Beliefs.UpdateMode.UpdateWhenSampled">
            <summary>
            Update the observation whenever a memory sample is stored.
            </summary>
        </member>
        <member name="T:Aplib.Core.Collections.CircularArray`1">
            <summary>
            An array that wraps around when it reaches its end.
            Functionally works like a queue with indexing.
            </summary>
        </member>
        <member name="P:Aplib.Core.Collections.CircularArray`1.Length">
            <summary>
            The length of the array.
            </summary>
        </member>
        <member name="M:Aplib.Core.Collections.CircularArray`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Collections.CircularArray`1"/> class.
            </summary>
            <param name="size">The size of the array.</param>
        </member>
        <member name="M:Aplib.Core.Collections.CircularArray`1.#ctor(`0[])">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Collections.CircularArray`1"/> class.
            </summary>
            <param name="array">An array to use as the circular array.</param>
        </member>
        <member name="P:Aplib.Core.Collections.CircularArray`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            <param name="index">The index of the element to get.</param>
            <returns>The element at the specified index.</returns>
        </member>
        <member name="M:Aplib.Core.Collections.CircularArray`1.DecrementHead">
            <summary>
            Decrements the head of the array.
            </summary>
        </member>
        <member name="M:Aplib.Core.Collections.CircularArray`1.Put(`0)">
            <summary>
            Puts an element at the start of the array.
            </summary>
            <param name="value">The element to add to the array</param>
        </member>
        <member name="M:Aplib.Core.Collections.CircularArray`1.GetHead">
            <summary>
            Gets the element at the head of the array.
            </summary>
            <returns>The element at the head of the array</returns>
        </member>
        <member name="M:Aplib.Core.Collections.CircularArray`1.GetFirst">
            <summary>
            Gets the first element of the array.
            </summary>
            <returns>The last element of the array</returns>
        </member>
        <member name="M:Aplib.Core.Collections.CircularArray`1.ToArray(System.Int32,System.Int32)">
            <summary>
            Converts the circular array to an array.
            The head should be the last element of the array.
            Copies from start to end inclusive.
            </summary>
            <param name="start">The start index of the range to copy.</param>
            <param name="end">The end index of the range to copy.</param>
            <returns>The circular array as a normal array</returns>
        </member>
        <member name="T:Aplib.Core.Collections.ExposedQueue`1">
            <summary>
            A queue with all elements exposed.
            Functionally works like a queue with indexing.
            It has a MaxCount and Count. MaxCount being the maximal length of the queue,
            and Count being the actual number of elements in the queue.
            </summary>
            <remarks>
            When adding an element to a full queue, all other elements are shifted one place like so:
            [4, 3, 2, 1], Put(5) => [5, 4, 3, 2]
            </remarks>
        </member>
        <member name="P:Aplib.Core.Collections.ExposedQueue`1.MaxCount">
            <summary>
            The length of the array.
            </summary>
        </member>
        <member name="P:Aplib.Core.Collections.ExposedQueue`1.Count">
            <summary>
            Actual number of elements in the array.
            </summary>
        </member>
        <member name="P:Aplib.Core.Collections.ExposedQueue`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.#ctor(System.Int32)">
            <summary>
            Initializes a new empty instance of the <see cref="T:Aplib.Core.Collections.ExposedQueue`1"/> class.
            </summary>
            <param name="size">The maximum size of the queue.</param>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.#ctor(`0[],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Collections.ExposedQueue`1"/> class with an array.
            </summary>
            <param name="array">The array to initialize the queue with.</param>
            <param name="maxCount">The maximum count of the queue.</param>
            <remarks>
            The array will be copied to the queue, and the head will be set to the last element of the array.
            This method expects the array to be filled.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the max count is negative.</exception>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.#ctor(`0[])">
            <inheritdoc cref="M:Aplib.Core.Collections.ExposedQueue`1.#ctor(`0[],System.Int32)" />
        </member>
        <member name="P:Aplib.Core.Collections.ExposedQueue`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index. Throws an exception if the index is out of bounds.
            </summary>
            <param name="index">The index of the element to get.</param>
            <returns>The element at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the index is out of range.
            </exception>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.Put(`0)">
            <summary>
            Puts an element at the start of the queue.
            </summary>
            <param name="value">The element to add to the queue.</param>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.GetLast">
            <summary>
            Gets the element at the end of the queue.
            </summary>
            <returns>The element at the end of the queue.</returns>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.GetFirst">
            <summary>
            Gets the first element of the queue.
            </summary>
            <returns>The first element of the queue.</returns>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.CopyTo(`0[],System.Int32,System.Int32)">
            <summary>
            Copies the ExposedQueue to an array.
            The head should be the last element of the array.
            Copies from start to end inclusive.
            </summary>
            <param name="array">The array to copy to."</param>
            <param name="arrayIndex">The start index of the range to copy.</param>
            <param name="endIndex">The end index of the range to copy.</param>
            <returns>The ExposedQueue as a regular array.</returns>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.ToArray(System.Int32,System.Int32)">
            <summary>
            Converts the ExposedQueue to an array.
            </summary>
            <param name="start">The start index of the range to convert.</param>
            <param name="end">The end index of the range to convert.</param>
            <returns>An array containing the elements within the specified range.</returns>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.ToArray">
            <summary>
            Converts the ExposedQueue to an array. Only returns the used slots.
            </summary>
            <returns>An array containing the elements within the specified range.</returns>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.Remove(`0)">
            <summary>
            Removes the specified item from the queue and shifts remaining elements to the left.
            For example, given the queue [4, 3, 2, 1], if you call Remove(3), the resulting queue will be [4, 2, 1].
            </summary>
            <param name="item">The item to remove.</param>
            <returns>True if the item was successfully removed; otherwise, false.</returns>
            <remarks>
            The MaxCount will not change, but the Count will decrease by one.
            </remarks>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.DecrementHead">
            <summary>
            Decrements the head of the array.
            </summary>
        </member>
        <member name="M:Aplib.Core.Collections.ExposedQueue`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified index.
            Shifts all other elements to the left.
            </summary>
            <param name="index">The index of the element to remove.</param>
        </member>
        <member name="T:Aplib.Core.Collections.OptimizedActivationStack`1">
            <summary>
            A stack that has a predefined set of items that can be <i>activated</i>
            (i.e., pushed on top of the stack).
            When an item that is already on the stack is activated, it is <i>reactivated</i>
            (i.e., moved to the top of the stack).
            </summary>
            <remarks>
            The <see cref="T:Aplib.Core.Collections.OptimizedActivationStack`1"/> allows for O(1) activation and
            reactivation of an arbitrary stack item.
            </remarks>
            <typeparam name="T">The type of the items that are put on the stack.</typeparam>
        </member>
        <member name="F:Aplib.Core.Collections.OptimizedActivationStack`1._top">
            <summary>
            The top item on the stack.
            </summary>
        </member>
        <member name="P:Aplib.Core.Collections.OptimizedActivationStack`1.ActivatableStackItems">
            <summary>
            Gets the activatable stack items.
            </summary>
            <remarks>
            The stack items are exposed, since they should be accessible from the outside to
            provide O(1) activation of a stack item with <see cref="M:Aplib.Core.Collections.OptimizedActivationStack`1.Activate(Aplib.Core.Collections.OptimizedActivationStack{`0}.StackItem)"/>.
            </remarks>
        </member>
        <member name="P:Aplib.Core.Collections.OptimizedActivationStack`1.Count">
            <summary>
            Gets the number of items that are currently activated (i.e., on the stack).
            </summary>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the stack count is negative.
            </exception>"
        </member>
        <member name="M:Aplib.Core.Collections.OptimizedActivationStack`1.#ctor(`0[])">
            <summary>
            Initializes an optimized activation stack with a set of activatable data.
            </summary>
            <param name="activatables">A set of activatable items that could be pushed on the stack.</param>
        </member>
        <member name="M:Aplib.Core.Collections.OptimizedActivationStack`1.Activate(Aplib.Core.Collections.OptimizedActivationStack{`0}.StackItem)">
            <summary>
            Activates an item (i.e., pushes an item on top of the stack).
            If the pushed item is already on the stack,
            it is extracted from the stack before it is put on top again.
            </summary>
            <param name="item">
            The stack item that is pushed on top of the stack (i.e., it is activated).
            </param>
            <exception cref="T:System.ArgumentException">
            Thrown when an item is pushed that belongs to a different stack.
            </exception>
        </member>
        <member name="M:Aplib.Core.Collections.OptimizedActivationStack`1.Peek">
            <summary>
            Peeks the top item from the stack.
            </summary>
            <returns>The top item.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the stack is empty.</exception>
        </member>
        <member name="M:Aplib.Core.Collections.OptimizedActivationStack`1.Pop">
            <summary>
            Pops the top item from the stack.
            </summary>
            <returns>The popped item.</returns>
            <exception cref="T:System.InvalidOperationException">Thrown when the stack is empty.</exception>
        </member>
        <member name="T:Aplib.Core.Collections.OptimizedActivationStack`1.StackItem">
            <summary>
            Represents (i.e., encapsulates) an item on the activation stack.
            </summary>
            <remarks>
            This class is public, because the whole stack item should be accessible from the outside to
            provide O(1) activation of a stack item with <see cref="M:Aplib.Core.Collections.OptimizedActivationStack`1.Activate(Aplib.Core.Collections.OptimizedActivationStack{`0}.StackItem)"/>.
            </remarks>
        </member>
        <member name="P:Aplib.Core.Collections.OptimizedActivationStack`1.StackItem.Data">
            <summary>
            Gets the data that this stack item represents.
            </summary>
        </member>
        <member name="P:Aplib.Core.Collections.OptimizedActivationStack`1.StackItem.ActivationStack">
            <summary>
            Gets the activation stack instance that this stack item belongs to.
            </summary>
        </member>
        <member name="P:Aplib.Core.Collections.OptimizedActivationStack`1.StackItem.Previous">
            <summary>
            Gets or sets the previous (below) item on the stack.
            </summary>
        </member>
        <member name="P:Aplib.Core.Collections.OptimizedActivationStack`1.StackItem.Next">
            <summary>
            Gets or sets the next (above) item on the stack.
            </summary>
        </member>
        <member name="P:Aplib.Core.Collections.OptimizedActivationStack`1.StackItem.IsActive">
            <summary>
            Gets or sets a value indicating whether the item is currently on the stack.
            </summary>
        </member>
        <member name="M:Aplib.Core.Collections.OptimizedActivationStack`1.StackItem.#ctor(`0,Aplib.Core.Collections.OptimizedActivationStack{`0})">
            <summary>
            Creates a stack item for the <see cref="T:Aplib.Core.Collections.OptimizedActivationStack`1"/> class.
            </summary>
            <param name="data">The data to put on the stack.</param>
            <param name="activationStack">The activation stack instance that this stack item belongs to.</param>
        </member>
        <member name="M:Aplib.Core.Collections.OptimizedActivationStack`1.StackItem.SetNext(Aplib.Core.Collections.OptimizedActivationStack{`0}.StackItem)">
            <summary>
            Links this item before another item.
            </summary>
            <param name="item">The item that should be on top.</param>
        </member>
        <member name="M:Aplib.Core.Collections.OptimizedActivationStack`1.StackItem.SetPrevious(Aplib.Core.Collections.OptimizedActivationStack{`0}.StackItem)">
            <summary>
            Links this item after another item.
            </summary>
            <param name="item">The item that should be below.</param>
        </member>
        <member name="M:Aplib.Core.Collections.OptimizedActivationStack`1.StackItem.PushOnStackAfter(Aplib.Core.Collections.OptimizedActivationStack{`0}.StackItem)">
            <summary>
            Pushes an item that is not on the stack yet after another item that is already on the stack.
            </summary>
            <param name="item">An item that is already on the stack.</param>
            <exception cref="T:System.ArgumentException">
            Thrown when an item is pushed after an item that is not on the same stack,
            when an item is already on the stack,
            or when an item is pushed after an item that is not on the stack.
            </exception>
        </member>
        <member name="M:Aplib.Core.Collections.OptimizedActivationStack`1.StackItem.RemoveFromStack">
            <summary>
            Safely remove the item from the stack.
            </summary>
        </member>
        <member name="T:Aplib.Core.Combinators">
            <summary>
            Convenience class containing static methods for creating goal structures and tactics.
            </summary>
        </member>
        <member name="M:Aplib.Core.Combinators.FirstOf``1(Aplib.Core.IMetadata,Aplib.Core.Desire.GoalStructures.IGoalStructure{``0}[])">
            <inheritdoc cref="M:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Desire.GoalStructures.IGoalStructure{`0}[])" />
        </member>
        <member name="M:Aplib.Core.Combinators.FirstOf``1(Aplib.Core.Desire.GoalStructures.IGoalStructure{``0}[])">
            <inheritdoc cref="M:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1.#ctor(Aplib.Core.Desire.GoalStructures.IGoalStructure{`0}[])" />
        </member>
        <member name="M:Aplib.Core.Combinators.Primitive``1(Aplib.Core.IMetadata,Aplib.Core.Desire.Goals.IGoal{``0})">
            <inheritdoc cref="M:Aplib.Core.Desire.GoalStructures.PrimitiveGoalStructure`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Desire.Goals.IGoal{`0})" />
        </member>
        <member name="M:Aplib.Core.Combinators.Primitive``1(Aplib.Core.Desire.Goals.IGoal{``0})">
            <inheritdoc cref="M:Aplib.Core.Desire.GoalStructures.PrimitiveGoalStructure`1.#ctor(Aplib.Core.Desire.Goals.IGoal{`0})" />
        </member>
        <member name="M:Aplib.Core.Combinators.Repeat``1(Aplib.Core.IMetadata,Aplib.Core.Desire.GoalStructures.IGoalStructure{``0})">
            <inheritdoc cref="M:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Desire.GoalStructures.IGoalStructure{`0})" />
        </member>
        <member name="M:Aplib.Core.Combinators.Repeat``1(Aplib.Core.Desire.GoalStructures.IGoalStructure{``0})">
            <inheritdoc cref="M:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1.#ctor(Aplib.Core.Desire.GoalStructures.IGoalStructure{`0})" />
        </member>
        <member name="M:Aplib.Core.Combinators.Seq``1(Aplib.Core.IMetadata,Aplib.Core.Desire.GoalStructures.IGoalStructure{``0}[])">
            <inheritdoc cref="M:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Desire.GoalStructures.IGoalStructure{`0}[])" />
        </member>
        <member name="M:Aplib.Core.Combinators.Seq``1(Aplib.Core.Desire.GoalStructures.IGoalStructure{``0}[])">
            <inheritdoc cref="M:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1.#ctor(Aplib.Core.Desire.GoalStructures.IGoalStructure{`0}[])" />
        </member>
        <member name="M:Aplib.Core.Combinators.Random``1(Aplib.Core.IMetadata,System.Predicate{``0},Aplib.Core.Intent.Tactics.ITactic{``0}[])">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.RandomTactic`1.#ctor(Aplib.Core.IMetadata,System.Predicate{`0},Aplib.Core.Intent.Tactics.ITactic{`0}[])" />
        </member>
        <member name="M:Aplib.Core.Combinators.Random``1(System.Predicate{``0},Aplib.Core.Intent.Tactics.ITactic{``0}[])">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.RandomTactic`1.#ctor(System.Predicate{`0},Aplib.Core.Intent.Tactics.ITactic{`0}[])" />
        </member>
        <member name="M:Aplib.Core.Combinators.Random``1(Aplib.Core.IMetadata,Aplib.Core.Intent.Tactics.ITactic{``0}[])">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.RandomTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Tactics.ITactic{`0}[])" />
        </member>
        <member name="M:Aplib.Core.Combinators.Random``1(Aplib.Core.Intent.Tactics.ITactic{``0}[])">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.RandomTactic`1.#ctor(Aplib.Core.Intent.Tactics.ITactic{`0}[])" />
        </member>
        <member name="M:Aplib.Core.Combinators.FirstOf``1(Aplib.Core.IMetadata,System.Predicate{``0},Aplib.Core.Intent.Tactics.ITactic{``0}[])">
            <inheritdoc
                cref="M:Aplib.Core.Intent.Tactics.FirstOfTactic`1.#ctor(Aplib.Core.IMetadata,System.Predicate{`0},Aplib.Core.Intent.Tactics.ITactic{`0}[])" />
        </member>
        <member name="M:Aplib.Core.Combinators.FirstOf``1(System.Predicate{``0},Aplib.Core.Intent.Tactics.ITactic{``0}[])">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.FirstOfTactic`1.#ctor(System.Predicate{`0},Aplib.Core.Intent.Tactics.ITactic{`0}[])" />
        </member>
        <member name="M:Aplib.Core.Combinators.FirstOf``1(Aplib.Core.IMetadata,Aplib.Core.Intent.Tactics.ITactic{``0}[])">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.FirstOfTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Tactics.ITactic{`0}[])"/>
        </member>
        <member name="M:Aplib.Core.Combinators.FirstOf``1(Aplib.Core.Intent.Tactics.ITactic{``0}[])">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.FirstOfTactic`1.#ctor(Aplib.Core.Intent.Tactics.ITactic{`0}[])"/>
        </member>
        <member name="M:Aplib.Core.Combinators.Primitive``1(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IAction{``0},System.Predicate{``0})">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IAction{`0},System.Predicate{`0})"/>
        </member>
        <member name="M:Aplib.Core.Combinators.Primitive``1(Aplib.Core.Intent.Actions.IAction{``0},System.Predicate{``0})">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.Intent.Actions.IAction{`0},System.Predicate{`0})"/>
        </member>
        <member name="M:Aplib.Core.Combinators.Primitive``1(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IAction{``0})">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IAction{`0})"/>
        </member>
        <member name="M:Aplib.Core.Combinators.Primitive``1(Aplib.Core.Intent.Actions.IAction{``0})">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.Intent.Actions.IAction{`0})"/>
        </member>
        <member name="M:Aplib.Core.Combinators.Primitive``1(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IQueryable{``0},System.Predicate{``0})">
            <inheritdoc
                cref="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IQueryable{`0},System.Predicate{`0})"/>
        </member>
        <member name="M:Aplib.Core.Combinators.Primitive``1(Aplib.Core.Intent.Actions.IQueryable{``0},System.Predicate{``0})">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.Intent.Actions.IQueryable{`0},System.Predicate{`0})"/>
        </member>
        <member name="M:Aplib.Core.Combinators.Primitive``1(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IQueryable{``0})">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IQueryable{`0})"/>
        </member>
        <member name="M:Aplib.Core.Combinators.Primitive``1(Aplib.Core.Intent.Actions.IQueryable{``0})">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.Intent.Actions.IQueryable{`0})"/>
        </member>
        <member name="T:Aplib.Core.CompletionStatus">
            <summary>
            Represents the state of a completable object.
            </summary>
        </member>
        <member name="F:Aplib.Core.CompletionStatus.Unfinished">
            <summary>
            The status of a completable object that is not yet completed.
            </summary>
        </member>
        <member name="F:Aplib.Core.CompletionStatus.Success">
            <summary>
            The status of a completable object that has been successfully completed.
            </summary>
        </member>
        <member name="F:Aplib.Core.CompletionStatus.Failure">
            <summary>
            The status of a completable object that has failed to complete.
            </summary>
        </member>
        <member name="T:Aplib.Core.Desire.DesireSets.DesireSet`1">
            <inheritdoc cref="T:Aplib.Core.Desire.DesireSets.DesireSet`1"/>
        </member>
        <member name="P:Aplib.Core.Desire.DesireSets.DesireSet`1.Metadata">
            <inheritdoc />
        </member>
        <member name="F:Aplib.Core.Desire.DesireSets.DesireSet`1._mainGoal">
            <summary>
            Stores the main goal structure of the agent.
            </summary>
        </member>
        <member name="F:Aplib.Core.Desire.DesireSets.DesireSet`1._goalStructureStack">
            <summary>
            Stores the side goal structures of the agent.
            Each of these goal structures has an accompanying guard that must be fulfilled to
            activate the goal structure (i.e., push the goal structure on top of the goal structure stack).
            All active goal structures of the agent that still need to be finished are pushed on the stack.
            </summary>
        </member>
        <member name="P:Aplib.Core.Desire.DesireSets.DesireSet`1.Status">
            <summary>
            If there are no goal structures left to be completed, the status of this desire set is set to the main goal status.
            </summary>
        </member>
        <member name="M:Aplib.Core.Desire.DesireSets.DesireSet`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Desire.GoalStructures.IGoalStructure{`0},System.ValueTuple{Aplib.Core.Desire.GoalStructures.IGoalStructure{`0},System.Predicate{`0}}[])">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Desire.DesireSets.DesireSet`1" /> class.
            </summary>
            <param name="metadata">
            Metadata about this GoalStructure, used to quickly display the goal in several contexts.
            </param>
            <param name="mainGoal">The main goal structure that the agent needs to complete.</param>
            <param name="sideGoals">The side goal structures that could be activated during the agent playthrough.</param>
        </member>
        <member name="M:Aplib.Core.Desire.DesireSets.DesireSet`1.#ctor(Aplib.Core.Desire.GoalStructures.IGoalStructure{`0},System.ValueTuple{Aplib.Core.Desire.GoalStructures.IGoalStructure{`0},System.Predicate{`0}}[])">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.DesireSets.DesireSet`1.ActivateRelevantGoalStructures(`0)">
            <summary>
            Pushes side goal structures on the stack if their guard is fulfilled.
            </summary>
            <param name="beliefSet">The belief set to check the guards of the goal structures with.</param>
        </member>
        <member name="M:Aplib.Core.Desire.DesireSets.DesireSet`1.GetCurrentGoal(`0)">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.DesireSets.DesireSet`1.Update(`0)">
            <summary>
            Activates side goal structures when their guard is satisfied, and updates the activation stack
            by popping goal structures from the top of the stack when they are finished.
            </summary>
            <param name="beliefSet">The belief set of the agent.</param>
        </member>
        <member name="M:Aplib.Core.Desire.DesireSets.DesireSet`1.GetLogChildren">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.DesireSets.DesireSet`1.op_Implicit(Aplib.Core.Desire.Goals.Goal{`0})~Aplib.Core.Desire.DesireSets.DesireSet{`0}">
            <summary>
            Implicitly lifts a goal into a desire set.
            </summary>
            <inheritdoc cref="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Desire.Goals.IGoal{``0},Aplib.Core.IMetadata)" path="/param[@name='goal']"/>
            <returns>The most logically matching desire set, wrapping around <paramref name="goal"/>.</returns>
        </member>
        <member name="M:Aplib.Core.Desire.DesireSets.DesireSet`1.op_Implicit(Aplib.Core.Desire.GoalStructures.GoalStructure{`0})~Aplib.Core.Desire.DesireSets.DesireSet{`0}">
            <summary>
            Implicitly lifts a goal structure a desire set.
            </summary>
            <inheritdoc cref="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Desire.GoalStructures.IGoalStructure{``0},Aplib.Core.IMetadata)" path="/param[@name='goalStructure']"/>
            <returns>The most logically matching desire set, wrapping around <paramref name="goalStructure"/>.</returns>
        </member>
        <member name="T:Aplib.Core.Desire.DesireSets.IDesireSet`1">
            <summary>
            Represents a set of goals that the agent has.
            This is the main structure that the agent will use to determine what it should do next.
            </summary>
            <typeparam name="TBeliefSet"></typeparam>
        </member>
        <member name="M:Aplib.Core.Desire.DesireSets.IDesireSet`1.GetCurrentGoal(`0)">
            <summary>
            Gets the current goal using the given <see cref="T:Aplib.Core.Belief.BeliefSets.IBeliefSet" />.
            </summary>
            <param name="beliefSet">The belief set of the agent.</param>
            <returns>The current goal to be fulfilled.</returns>
        </member>
        <member name="M:Aplib.Core.Desire.DesireSets.IDesireSet`1.Update(`0)">
            <summary>
            Updates the status of this <see cref="T:Aplib.Core.Desire.DesireSets.IDesireSet`1"/>.
            </summary>
            <param name="beliefSet">The belief set of the agent.</param>
        </member>
        <member name="T:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1">
            <summary>
            Represents a goal structure that will complete if any one of its children completes.
            </summary>
            <remarks>
            The children of this goal structure will be executed in the order they are given.
            </remarks>
            <typeparam name="TBeliefSet">The beliefset of the agent.</typeparam>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Desire.GoalStructures.IGoalStructure{`0}[])">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1" /> class.
            </summary>
            <param name="metadata">
            Metadata about this GoalStructure, used to quickly display the goal in several contexts.
            </param>
            <param name="children">The children of the goal structure.</param>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1.#ctor(Aplib.Core.Desire.GoalStructures.IGoalStructure{`0}[])">
            <inheritdoc cref="M:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Desire.GoalStructures.IGoalStructure{`0}[])"/>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1.GetCurrentGoal(`0)">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1.UpdateStatus(`0)">
            <summary>
            Updates the status of the <see cref="T:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1" />.
            The goal structure status is set to:
            <list type="bullet">
                <item>
                    <term><see cref="F:Aplib.Core.CompletionStatus.Success"/></term>
                    <description>When any one of its children is successful.</description>
                </item>
                <item>
                    <term><see cref="F:Aplib.Core.CompletionStatus.Failure"/></term>
                    <description>When all children fail.</description>
                </item>
                <item>
                    <term><see cref="F:Aplib.Core.CompletionStatus.Unfinished"/></term>
                    <description>Otherwise.</description>
                </item>
            </list>
            </summary>
            <param name="beliefSet">The belief set of the agent.</param>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1.Reset">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1.Dispose(System.Boolean)">
            <summary>
            Disposes of the goal structure.
            </summary>
            <param name="disposing">Whether we are actually disposing.</param>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1.GetLogChildren">
            <inheritdoc />
        </member>
        <member name="T:Aplib.Core.Desire.GoalStructures.GoalStructure`1">
            <summary>
            Describes a structure of goals that need to be fulfilled.
            </summary>
        </member>
        <member name="P:Aplib.Core.Desire.GoalStructures.GoalStructure`1.Metadata">
            <inheritdoc />
        </member>
        <member name="F:Aplib.Core.Desire.GoalStructures.GoalStructure`1._children">
            <summary>
            The children of the goal structure.
            </summary>
        </member>
        <member name="P:Aplib.Core.Desire.GoalStructures.GoalStructure`1.Status">
            <inheritdoc />
        </member>
        <member name="F:Aplib.Core.Desire.GoalStructures.GoalStructure`1._currentGoalStructure">
            <summary>
            The goal structure that is currently being fulfilled.
            </summary>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.GoalStructure`1.#ctor(Aplib.Core.IMetadata,System.Collections.Generic.IEnumerable{Aplib.Core.Desire.GoalStructures.IGoalStructure{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Desire.GoalStructures.GoalStructure`1" /> class.
            </summary>
            <param name="metadata">
            Metadata about this GoalStructure, used to quickly display the goal in several contexts.
            </param>
            <param name="children">The children of the goal structure.</param>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.GoalStructure`1.#ctor(System.Collections.Generic.IEnumerable{Aplib.Core.Desire.GoalStructures.IGoalStructure{`0}})">
            <inheritdoc cref="M:Aplib.Core.Desire.GoalStructures.GoalStructure`1.#ctor(Aplib.Core.IMetadata,System.Collections.Generic.IEnumerable{Aplib.Core.Desire.GoalStructures.IGoalStructure{`0}})" />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.GoalStructure`1.GetCurrentGoal(`0)">
            <summary>
            Gets the current goal using the given <see cref="T:Aplib.Core.Belief.BeliefSets.IBeliefSet" />.
            </summary>
            <param name="beliefSet">The belief set of the agent.</param>
            <returns>The current goal to be fulfilled.</returns>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.GoalStructure`1.UpdateStatus(`0)">
            <summary>
            Updates the state of the goal structure.
            </summary>
            <param name="beliefSet">The belief set of the agent.</param>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.GoalStructure`1.Reset">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.GoalStructure`1.GetLogChildren">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.GoalStructure`1.op_Implicit(Aplib.Core.Desire.Goals.Goal{`0})~Aplib.Core.Desire.GoalStructures.GoalStructure{`0}">
            <summary>
            Implicitly lifts a goal into a goal structure.
            </summary>
            <inheritdoc cref="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Desire.Goals.IGoal{``0},Aplib.Core.IMetadata)" path="/param[@name='goal']"/>
            <returns>The most logically matching goal structure, wrapping around <paramref name="goal"/>.</returns>
        </member>
        <member name="T:Aplib.Core.Desire.GoalStructures.IGoalStructure`1">
            <summary>
            Represents a goal structure.
            </summary>
            <remarks>
            A goal structure is a structure of predicates that must be fulfilled in order to complete a test.
            </remarks>
            <typeparam name="TBeliefSet">The belief set of the agent.</typeparam>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.IGoalStructure`1.GetCurrentGoal(`0)">
            <summary>
            Gets the current goal using the given <see cref="T:Aplib.Core.Belief.BeliefSets.IBeliefSet" />.
            </summary>
            <param name="beliefSet">The belief set of the agent.</param>
            <returns>The current goal to be fulfilled.</returns>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.IGoalStructure`1.UpdateStatus(`0)">
            <summary>
            Updates the state of the goal structure.
            </summary>
            <param name="beliefSet">The belief set of the agent.</param>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.IGoalStructure`1.Reset">
            <summary>
            Resets the goal structure to its initial state.
            </summary>
        </member>
        <member name="T:Aplib.Core.Desire.GoalStructures.PrimitiveGoalStructure`1">
            <summary>
            Represents a goal structure that will complete if any of its children complete.
            </summary>
            <remarks>
            This is the most primitive goal structure. It is used to represent a single goal that is not part of a larger
            structure.
            This goal structure will only return the goal it was created with if the goal is not yet finished.
            </remarks>
            <typeparam name="TBeliefSet">The beliefset of the agent.</typeparam>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.PrimitiveGoalStructure`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Desire.Goals.IGoal{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Desire.GoalStructures.PrimitiveGoalStructure`1" /> class.
            </summary>
            <param name="metadata">
            Metadata about this GoalStructure, used to quickly display the goal in several contexts.
            </param>
            <param name="goal">The goal to fulfill.</param>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.PrimitiveGoalStructure`1.#ctor(Aplib.Core.Desire.Goals.IGoal{`0})">
            <inheritdoc cref="M:Aplib.Core.Desire.GoalStructures.PrimitiveGoalStructure`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Desire.Goals.IGoal{`0})"/>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.PrimitiveGoalStructure`1.GetCurrentGoal(`0)">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.PrimitiveGoalStructure`1.UpdateStatus(`0)">
            <summary>
            Updates the status of the <see cref="T:Aplib.Core.Desire.GoalStructures.FirstOfGoalStructure`1" />.
            The goal structure status is set to the status of the underlying <see cref="T:Aplib.Core.Desire.Goals.IGoal`1" />.
            </summary>
            <param name="beliefSet">The belief set of the agent.</param>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.PrimitiveGoalStructure`1.GetLogChildren">
            <inheritdoc />
        </member>
        <member name="T:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1">
            <summary>
            Represents a goal structure that will complete if any of its children complete.
            This structure will repeatedly execute the goal it was created with until the goal is finished,
            or the maximum number of retries is reached.
            </summary>
            <typeparam name="TBeliefSet">The belief set of the agent.</typeparam>
        </member>
        <member name="F:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1._maxRetries">
            <summary>
            The maximum number of times to retry the goal after it has failed.
            If this is <c>null</c>, the goal will be retried indefinitely.
            </summary>
        </member>
        <member name="F:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1._retryCount">
            <summary>
            The number of times the goal has been retried so far.
            </summary>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Desire.GoalStructures.IGoalStructure{`0},System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1.#ctor(Aplib.Core.Desire.GoalStructures.IGoalStructure{`0},System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Desire.GoalStructures.IGoalStructure{`0})">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1.#ctor(Aplib.Core.Desire.GoalStructures.IGoalStructure{`0})">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Desire.GoalStructures.IGoalStructure{`0},System.Nullable{System.Int32})">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1" /> class.
            </summary>
            <param name="metadata">
            Metadata about this goal, used to quickly display the goal in several contexts.
            </param>
            <param name="goalStructure">The GoalStructure to repeat.</param>
            <param name="maxRetries">
            The maximum number of times to retry the goal after it has failed.
            If omitted, the goal will be retried indefinitely.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="maxRetries"/> is less than zero.
            </exception>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1.GetCurrentGoal(`0)">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1.UpdateStatus(`0)">
            <summary>
            Updates the status of the <see cref="T:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1" />.
            The goal structure status is set to:
            <list type="bullet">
                <item>
                    <term><see cref="F:Aplib.Core.CompletionStatus.Success"/></term>
                    <description>When the underlying goal structure is successful.</description>
                </item>
                <item>
                    <term><see cref="F:Aplib.Core.CompletionStatus.Failure"/></term>
                    <description>
                        If the underlying goal structure fails when the maximum number of retries has been reached.
                        But never if no maximum number of retries has been specified.
                    </description>
                </item>
                <item>
                    <term><see cref="F:Aplib.Core.CompletionStatus.Unfinished"/></term>
                    <description>
                        When the underlying goal structure is unfinished.
                        The underlying goal structure will be retried when it fails.
                    </description>
                </item>
            </list>
            </summary>
            <param name="beliefSet">The belief set of the agent.</param>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.RepeatGoalStructure`1.GetLogChildren">
            <inheritdoc />
        </member>
        <member name="T:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1">
            <summary>
            Represents a goal structure that will complete if all of its children complete.
            </summary>
            <remarks>
            The children of this goal structure will be executed in the order they are given.
            </remarks>
            <typeparam name="TBeliefSet">The type of belief set that this goal structure operates on.</typeparam>
        </member>
        <member name="F:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1._childrenEnumerator">
            <summary>
            Gets or sets the enumerator for the children of the goal structure.
            </summary>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Desire.GoalStructures.IGoalStructure{`0}[])">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1" /> class.
            </summary>
            <param name="metadata">
            Metadata about this GoalStructure, used to quickly display the goal in several contexts.
            </param>
            <param name="children">The children of the goal structure.</param>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1.#ctor(Aplib.Core.Desire.GoalStructures.IGoalStructure{`0}[])">
            <inheritdoc cref="M:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Desire.GoalStructures.IGoalStructure{`0}[])" />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1.GetCurrentGoal(`0)">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1.UpdateStatus(`0)">
            <summary>
            Updates the status of the <see cref="T:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1" />.
            The goal structure status is set to:
            <list type="bullet">
                <item>
                    <term><see cref="F:Aplib.Core.CompletionStatus.Success"/></term>
                    <description>When all children are successful.</description>
                </item>
                <item>
                    <term><see cref="F:Aplib.Core.CompletionStatus.Failure"/></term>
                    <description>When any one of its children fails.</description>
                </item>
                <item>
                    <term><see cref="F:Aplib.Core.CompletionStatus.Unfinished"/></term>
                    <description>Otherwise.</description>
                </item>
            </list>
            </summary>
            <param name="beliefSet">The belief set of the agent.</param>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1.Reset">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1.Dispose(System.Boolean)">
            <summary>
            Disposes the enumerator.
            </summary>
            <param name="disposing">Whether the object is being disposed.</param>
        </member>
        <member name="M:Aplib.Core.Desire.GoalStructures.SequentialGoalStructure`1.GetLogChildren">
            <inheritdoc />
        </member>
        <member name="T:Aplib.Core.Desire.Goals.Goal`1">
            <summary>
            A goal effectively combines a heuristic function with a tactic, and aims to meet the heuristic function by
            applying the tactic. Goals are combined in a <see cref="T:Aplib.Core.Desire.GoalStructures.GoalStructure`1" />, and are used to
            prepare tests or do the testing.
            </summary>
            <seealso cref="T:Aplib.Core.Desire.GoalStructures.GoalStructure`1" />
            <typeparam name="TBeliefSet">The belief set of the agent.</typeparam>
        </member>
        <member name="F:Aplib.Core.Desire.Goals.Goal`1._predicate">
            <summary>
            A predicate that determines whether the goal has succeeded.
            Intuitively, the predicate is the goal itself.
            </summary>
        </member>
        <member name="F:Aplib.Core.Desire.Goals.Goal`1._failGuard">
            <summary>
            An (optional) fail-guard for the goal's completion status.
            The fail-guard predicate is a condition that, when true, indicates that the goal has failed.
            </summary>
        </member>
        <member name="P:Aplib.Core.Desire.Goals.Goal`1.Metadata">
            <inheritdoc />
        </member>
        <member name="P:Aplib.Core.Desire.Goals.Goal`1.Tactic">
            <summary>
            The <see cref="T:Aplib.Core.Intent.Tactics.Tactic`1" /> used to achieve this <see cref="T:Aplib.Core.Desire.Goals.Goal`1" />.
            It is executed once in every iteration of the BDI cycle while this goal is the active goal of the agent.
            </summary>
        </member>
        <member name="P:Aplib.Core.Desire.Goals.Goal`1.Status">
            <summary>
            Gets the completion status of the goal.
            This value may need to be updated first using the <see cref="M:Aplib.Core.Desire.Goals.Goal`1.UpdateStatus(`0)"/> method.
            </summary>
            <seealso cref="M:Aplib.Core.Desire.Goals.Goal`1.UpdateStatus(`0)"/>
        </member>
        <member name="M:Aplib.Core.Desire.Goals.Goal`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Tactics.ITactic{`0},System.Predicate{`0},System.Predicate{`0})">
            <summary>
            Initializes a new goal from a given tactic and a success predicate, and an optional fail-guard.
            </summary>
            <param name="metadata">
            Metadata about this goal, used to quickly display the goal in several contexts.
            If omitted, default metadata will be generated.
            </param>
            <param name="tactic">The tactic used to approach this goal.</param>
            <param name="predicate">A predicate that determines when the goal has succeeded.</param>
            <param name="failGuard">
            A predicate that determines when the goal has failed.
            If the fail-guard is true,
            but the success predicate is also satisfied, the success predicate takes precedence.
            If omitted, the goal will never fail.
            </param>
        </member>
        <member name="M:Aplib.Core.Desire.Goals.Goal`1.#ctor(Aplib.Core.Intent.Tactics.ITactic{`0},System.Predicate{`0},System.Predicate{`0})">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.Goals.Goal`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Tactics.ITactic{`0},System.Predicate{`0})">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.Goals.Goal`1.#ctor(Aplib.Core.Intent.Tactics.ITactic{`0},System.Predicate{`0})">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Desire.Goals.Goal`1.UpdateStatus(`0)">
            <summary>
            <para>Checks whether the goal has been achieved and stores the result in <see cref="P:Aplib.Core.Desire.Goals.Goal`1.Status"/>.</para>
            <para>
            If the predicate of the goal is satisfied, the goal is considered to have succeeded.
            If the fail-guard is satisfied, the goal is considered to have failed.
            If both are satisfied, the success predicate takes precedence.
            If neither are satisfied, the goal is considered unfinished.
            The table below summarizes the possible outcomes:
            <list type="table">
                <listheader>
                    <term>Predicate</term>
                    <term>Fail guard</term>
                    <term>Result</term>
                </listheader>
                <item>
                    <description><c>true</c></description>
                    <description><c>false</c></description>
                    <description><see cref="F:Aplib.Core.CompletionStatus.Success"/></description>
                </item>
                <item>
                    <description><c>true</c></description>
                    <description><c>true</c></description>
                    <description><see cref="F:Aplib.Core.CompletionStatus.Success"/></description>
                </item>
                <item>
                    <description><c>false</c></description>
                    <description><c>true</c></description>
                    <description><see cref="F:Aplib.Core.CompletionStatus.Failure"/></description>
                </item>
                <item>
                    <description><c>false</c></description>
                    <description><c>false</c></description>
                    <description><see cref="F:Aplib.Core.CompletionStatus.Unfinished"/></description>
                </item>
            </list>
            </para>
            <remarks>Use <see cref="P:Aplib.Core.Desire.Goals.Goal`1.Status"/> to get the updated value.</remarks>
            </summary>
            <param name="beliefSet">The belief set of the agent.</param>
        </member>
        <member name="M:Aplib.Core.Desire.Goals.Goal`1.GetLogChildren">
            <inheritdoc />
        </member>
        <member name="T:Aplib.Core.Desire.Goals.IGoal`1">
            <summary>
            Defines a goal that can be achieved by a <see cref="T:Aplib.Core.Intent.Tactics.Tactic`1" />.
            </summary>
            <typeparam name="TBeliefSet">The belief set of the agent.</typeparam>
        </member>
        <member name="P:Aplib.Core.Desire.Goals.IGoal`1.Tactic">
            <summary>
            The <see cref="T:Aplib.Core.Intent.Tactics.Tactic`1" /> used to achieve this <see cref="T:Aplib.Core.Desire.Goals.Goal`1" />, which is executed during every
            iteration of the BDI cycle.
            </summary>
        </member>
        <member name="M:Aplib.Core.Desire.Goals.IGoal`1.UpdateStatus(`0)">
            <summary>
            Tests whether the goal has been achieved, based on the heuristic function of the goal.
            The new completion status can be accessed via the <see cref="P:Aplib.Core.ICompletable.Status"/> property.
            </summary>
            <seealso cref="P:Aplib.Core.ICompletable.Status"/>
        </member>
        <member name="T:Aplib.Core.ICompletable">
            <summary>
            Defines an object that can be completed.
            </summary>
        </member>
        <member name="P:Aplib.Core.ICompletable.Status">
            <summary>
            Gets the completion status of the instance.
            </summary>
        </member>
        <member name="T:Aplib.Core.IDocumented">
            <summary>
            Represents an object that contains general information on an instance, such as <see cref="T:Aplib.Core.IMetadata" />.
            </summary>
        </member>
        <member name="P:Aplib.Core.IDocumented.Metadata">
            <summary>
            Gets the metadata of the instance. This metadata may be useful for debugging or logging.
            </summary>
        </member>
        <member name="T:Aplib.Core.IMetadata">
            <summary>
            A collection of generic metadata for unique instances which should help
            visualize the instance with human-readable information.
            This metadata may be useful for debugging or logging.
            </summary>
        </member>
        <member name="P:Aplib.Core.IMetadata.Id">
            <summary>
            Gets the unique identifier of the instance.
            </summary>
        </member>
        <member name="P:Aplib.Core.IMetadata.Name">
            <summary>
            Gets the name used to display the instance.
            </summary>
        </member>
        <member name="P:Aplib.Core.IMetadata.Description">
            <summary>
            Gets the description used to describe the instance.
            </summary>
        </member>
        <member name="T:Aplib.Core.Intent.Actions.Action`1">
            <summary>
            Describes an action that can be executed and guarded.
            </summary>
            <typeparam name="TBeliefSet">The belief set of the agent.</typeparam>
        </member>
        <member name="F:Aplib.Core.Intent.Actions.Action`1._effect">
            <summary>
            Gets or sets the effect of the action.
            </summary>
        </member>
        <member name="P:Aplib.Core.Intent.Actions.Action`1.Metadata">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Intent.Actions.Action`1.#ctor(Aplib.Core.IMetadata,System.Action{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Intent.Actions.Action`1" /> class.
            </summary>=
            <param name="metadata">
            Metadata about this action, used to quickly display the action in several contexts.
            </param>
            <param name="effect">The effect of the action.</param>
        </member>
        <member name="M:Aplib.Core.Intent.Actions.Action`1.#ctor(System.Action{`0})">
            <inheritdoc cref="M:Aplib.Core.Intent.Actions.Action`1.#ctor(Aplib.Core.IMetadata,System.Action{`0})"/>
        </member>
        <member name="M:Aplib.Core.Intent.Actions.Action`1.Execute(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Aplib.Core.Intent.Actions.Action`1.GetLogChildren">
            <summary>
            Actions do not have children, as they are the lowest level of the hierarchy.
            </summary>
            <returns>An empty enumerable.</returns>
        </member>
        <member name="T:Aplib.Core.Intent.Actions.IAction`1">
            <summary>
            Represents an action that can be executed on a belief set.
            </summary>
            <typeparam name="TBeliefSet">The type of the belief set that the action uses.</typeparam>
        </member>
        <member name="M:Aplib.Core.Intent.Actions.IAction`1.Execute(`0)">
            <summary>
            Executes the action on the specified belief set.
            </summary>
            <param name="beliefSet">The belief set on which the action is executed.</param>
        </member>
        <member name="T:Aplib.Core.Intent.Actions.IQueryable`1">
            <summary>
            Represents an interface for executing queries on a belief set.
            </summary>
            <typeparam name="TBeliefSet">The type of the query object.</typeparam>
        </member>
        <member name="M:Aplib.Core.Intent.Actions.IQueryable`1.Query(`0)">
            <summary>
            Executes a query on the specified belief set.
            </summary>
            <param name="beliefSet">The belief set to query.</param>
            <returns>A boolean value indicating whether the query executed successfully or not.</returns>
        </member>
        <member name="T:Aplib.Core.Intent.Actions.QueryAction`2">
            <summary>
            Describes an action that can be executed and guarded with a query that stores a result.
            The result can be used in the effect.
            </summary>
            <typeparam name="TBeliefSet">The belief set of the agent.</typeparam>
            <typeparam name="TQuery">The type of the query of the action</typeparam>
        </member>
        <member name="F:Aplib.Core.Intent.Actions.QueryAction`2._effect">
            <summary>
            Gets or sets the effect of the action.
            </summary>
        </member>
        <member name="F:Aplib.Core.Intent.Actions.QueryAction`2._query">
            <summary>
            Gets or sets the query of the action.
            </summary>
        </member>
        <member name="F:Aplib.Core.Intent.Actions.QueryAction`2._storedQueryResult">
            <summary>
            Gets or sets the result of the query.
            </summary>
        </member>
        <member name="M:Aplib.Core.Intent.Actions.QueryAction`2.#ctor(Aplib.Core.IMetadata,System.Action{`0,`1},System.Func{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Intent.Actions.QueryAction`2" /> class.
            </summary>
            <param name="metadata">
            Metadata about this action, used to quickly display the action in several contexts.
            </param>
            <param name="effect">The effect of the action.</param>
            <param name="query">The query of the action.</param>
        </member>
        <member name="M:Aplib.Core.Intent.Actions.QueryAction`2.#ctor(System.Action{`0,`1},System.Func{`0,`1})">
            <inheritdoc
                cref="M:Aplib.Core.Intent.Actions.QueryAction`2.#ctor(Aplib.Core.IMetadata,System.Action{`0,`1},System.Func{`0,`1})" />
        </member>
        <member name="M:Aplib.Core.Intent.Actions.QueryAction`2.Execute(`0)">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Intent.Actions.QueryAction`2.Query(`0)">
            <summary>
            Queries the environment for the queried item and returns whether the query is not null.
            </summary>
            <param name="beliefSet">The belief set of the agent.</param>
            <returns>True if the query is not null; otherwise, false.</returns>
        </member>
        <member name="T:Aplib.Core.Intent.Tactics.FirstOfTactic`1">
            <summary>
            Represents a tactic that executes the first enabled action from a list of subtactics.
            </summary>
        </member>
        <member name="F:Aplib.Core.Intent.Tactics.FirstOfTactic`1._subtactics">
            <summary>
            Gets or sets the subtactics of the tactic.
            </summary>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.FirstOfTactic`1.#ctor(Aplib.Core.IMetadata,System.Predicate{`0},Aplib.Core.Intent.Tactics.ITactic{`0}[])">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Intent.Tactics.FirstOfTactic`1"/> class with the specified
            subtactics and guard condition.
            </summary>
            <param name="metadata">
            Metadata about this tactic, used to quickly display the tactic in several contexts.
            </param>
            <param name="guard">The guard condition.</param>
            <param name="subtactics">The list of subtactics.</param>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.FirstOfTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Tactics.ITactic{`0}[])">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.FirstOfTactic`1.#ctor(Aplib.Core.IMetadata,System.Predicate{`0},Aplib.Core.Intent.Tactics.ITactic{`0}[])"/>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.FirstOfTactic`1.#ctor(System.Predicate{`0},Aplib.Core.Intent.Tactics.ITactic{`0}[])">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.FirstOfTactic`1.#ctor(Aplib.Core.IMetadata,System.Predicate{`0},Aplib.Core.Intent.Tactics.ITactic{`0}[])"/>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.FirstOfTactic`1.#ctor(Aplib.Core.Intent.Tactics.ITactic{`0}[])">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.FirstOfTactic`1.#ctor(Aplib.Core.IMetadata,System.Predicate{`0},Aplib.Core.Intent.Tactics.ITactic{`0}[])"/>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.FirstOfTactic`1.GetAction(`0)">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.FirstOfTactic`1.GetLogChildren">
            <inheritdoc/>
        </member>
        <member name="T:Aplib.Core.Intent.Tactics.ITactic`1">
            <summary>
            Represents a tactic that an agent can use to achieve its goals.
            A tactic is a strategy for achieving a particular goal.
            </summary>
            <typeparam name="TBeliefSet">The type of the belief set that the tactic uses.</typeparam>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.ITactic`1.GetAction(`0)">
            <summary>
            Gets the first enabled action of the tactic.
            </summary>
            <remark>
            An action is a specific operation that an agent can perform.
            The action returned by this method is the first action that the tactic can perform,
            given the current state of the world as represented by the belief set.
            </remark>
            <returns>
            A concrete <see cref="T:Aplib.Core.Intent.Actions.IAction`1"/> that the tactic can perform, or null if no actions are enabled.
            </returns>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.ITactic`1.IsActionable(`0)">
            <summary>
            Determines whether the tactic is actionable.
            </summary>
            <returns>True if the tactic is actionable, false otherwise.</returns>
        </member>
        <member name="T:Aplib.Core.Intent.Tactics.PrimitiveTactic`1">
            <summary>
            Represents a primitive tactic
            </summary>
            <typeparam name="TBeliefSet">The belief set of the agent.</typeparam>
        </member>
        <member name="F:Aplib.Core.Intent.Tactics.PrimitiveTactic`1._action">
            <summary>
            Gets the action of the primitive tactic.
            </summary>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IAction{`0},System.Predicate{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Intent.Tactics.PrimitiveTactic`1"/> class with the specified action
            and guard.
            </summary>
            <param name="metadata">
            Metadata about this tactic, used to quickly display the tactic in several contexts.
            </param>
            <param name="action">The action of the primitive tactic.</param>
            <param name="guard">The guard of the primitive tactic.</param>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.Intent.Actions.IAction{`0},System.Predicate{`0})">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IAction{`0},System.Predicate{`0})"/>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IAction{`0})">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IAction{`0},System.Predicate{`0})"/>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.Intent.Actions.IAction{`0})">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IAction{`0},System.Predicate{`0})"/>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IQueryable{`0},System.Predicate{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Intent.Tactics.PrimitiveTactic`1"/> class with the specified action
            and guard.
            </summary>
            <param name="metadata">
            Metadata about this tactic, used to quickly display the tactic in several contexts.
            </param>
            <param name="queryAction">The queryable action of the primitive tactic.</param>
            <param name="guard">The guard of the primitive tactic.</param>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.Intent.Actions.IQueryable{`0},System.Predicate{`0})">
            <inheritdoc
                cref="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IQueryable{`0},System.Predicate{`0})" />
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IQueryable{`0})">
            <inheritdoc
                cref="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IQueryable{`0},System.Predicate{`0})" />
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.Intent.Actions.IQueryable{`0})">
            <inheritdoc
                cref="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Actions.IQueryable{`0},System.Predicate{`0})"/>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.GetAction(`0)">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.PrimitiveTactic`1.GetLogChildren">
            <inheritdoc />
        </member>
        <member name="T:Aplib.Core.Intent.Tactics.RandomTactic`1">
            <summary>
            Represents a tactic that executes a random tactic from the provided subtactics.
            </summary>
        </member>
        <member name="F:Aplib.Core.Intent.Tactics.RandomTactic`1._subtactics">
            <summary>
            Gets or sets the subtactics of the tactic.
            </summary>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.RandomTactic`1.#ctor(Aplib.Core.IMetadata,System.Predicate{`0},Aplib.Core.Intent.Tactics.ITactic{`0}[])">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Intent.Tactics.RandomTactic`1"/> class with the specified subtactics
            and an optional guard condition.
            </summary>
            <param name="metadata">
            Metadata about this tactic, used to quickly display the tactic in several contexts.
            </param>
            <param name="guard">The guard condition.</param>
            <param name="subtactics">The list of subtactics.</param>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.RandomTactic`1.#ctor(System.Predicate{`0},Aplib.Core.Intent.Tactics.ITactic{`0}[])">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.RandomTactic`1.#ctor(Aplib.Core.IMetadata,System.Predicate{`0},Aplib.Core.Intent.Tactics.ITactic{`0}[])"/>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.RandomTactic`1.#ctor(Aplib.Core.IMetadata,Aplib.Core.Intent.Tactics.ITactic{`0}[])">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.RandomTactic`1.#ctor(Aplib.Core.IMetadata,System.Predicate{`0},Aplib.Core.Intent.Tactics.ITactic{`0}[])" />
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.RandomTactic`1.#ctor(Aplib.Core.Intent.Tactics.ITactic{`0}[])">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.RandomTactic`1.#ctor(Aplib.Core.IMetadata,System.Predicate{`0},Aplib.Core.Intent.Tactics.ITactic{`0}[])" />
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.RandomTactic`1.GetAction(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.RandomTactic`1.GetLogChildren">
            <inheritdoc/>
        </member>
        <member name="T:Aplib.Core.Intent.Tactics.Tactic`1">
            <summary>
            Tactics are the real meat of <see cref="T:Aplib.Core.Desire.Goals.Goal`1"/>s, as they define how the agent can approach the goal in hopes
            of finding a solution which makes the Goal's heuristic function evaluate to being completed. A tactic represents
            a smart combination of <see cref="T:Aplib.Core.Intent.Actions.Action`1"/>s, which are executed in a Belief Desire Intent Cycle.
            </summary>
            <seealso cref="T:Aplib.Core.Desire.Goals.Goal`1"/>
            <seealso cref="T:Aplib.Core.Intent.Actions.Action`1"/>
            <typeparam name="TBeliefSet">The belief set of the agent.</typeparam>
        </member>
        <member name="F:Aplib.Core.Intent.Tactics.Tactic`1._guard">
            <summary>
            Gets or sets the guard of the tactic.
            </summary>
        </member>
        <member name="P:Aplib.Core.Intent.Tactics.Tactic`1.Metadata">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.Tactic`1.#ctor(Aplib.Core.IMetadata,System.Predicate{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Aplib.Core.Intent.Tactics.Tactic`1"/> class with a specified guard.
            </summary>
            <param name="metadata">
            Metadata about this tactic, used to quickly display the tactic in several contexts.
            </param>
            <param name="guard">The guard of the tactic.</param>
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.Tactic`1.#ctor(System.Predicate{`0})">
            <inheritdoc cref="M:Aplib.Core.Intent.Tactics.Tactic`1.#ctor(Aplib.Core.IMetadata,System.Predicate{`0})" />
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.Tactic`1.#ctor(Aplib.Core.IMetadata)">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.Tactic`1.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.Tactic`1.GetAction(`0)">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.Tactic`1.IsActionable(`0)">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.Tactic`1.GetLogChildren">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Intent.Tactics.Tactic`1.op_Implicit(Aplib.Core.Intent.Actions.Action{`0})~Aplib.Core.Intent.Tactics.Tactic{`0}">
            <summary>
            Implicitly lifts an action into a tactic.
            </summary>
            <inheritdoc cref="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Intent.Actions.IAction{``0},Aplib.Core.IMetadata)" path="/param[@name='action']"/>
            <returns>The most logically matching tactic, wrapping around <paramref name="action"/>.</returns>
        </member>
        <member name="T:Aplib.Core.LiftingExtensionMethods">
            <summary>
            Contains extension methods for lifting BDI cycle components into higher-order components.
            </summary>
        </member>
        <member name="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Intent.Actions.IAction{``0},Aplib.Core.IMetadata)">
            <summary>
            Wraps a normal action into a tactic.
            </summary>
            <param name="action">
            The action which on its own can function as a tactic. Meaning, the tactic consists of just a single action.
            </param>
            <param name="metadata">Optional metadata to be assigned to the tactic.</param>
            <returns>The action, lifted to a primitive tactic, whose guard always returns true.</returns>
        </member>
        <member name="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Intent.Actions.IAction{``0})">
            <inheritdoc cref="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Intent.Actions.IAction{``0},Aplib.Core.IMetadata)" />
        </member>
        <member name="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Intent.Actions.IQueryable{``0},Aplib.Core.IMetadata)">
            <summary>
            Wraps a queryable action into a tactic.
            </summary>
            <param name="action">
            The action which on its own can function as a tactic. Meaning, the tactic consists of just a single action.
            </param>
            <param name="metadata">Optional metadata to be assigned to the tactic.</param>
            <returns>The action, lifted to a primitive tactic, whose guard always returns true.</returns>
        </member>
        <member name="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Intent.Actions.IQueryable{``0})">
            <inheritdoc cref="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Intent.Actions.IQueryable{``0},Aplib.Core.IMetadata)" />
        </member>
        <member name="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Desire.Goals.IGoal{``0},Aplib.Core.IMetadata)">
            <summary>
            Wraps a goal into a goal structure.
            </summary>
            <param name="goal">
            The goal which on its own can function as a goal structure. Meaning, the goal structure consists of just a
            single goal.
            </param>
            <param name="metadata">Optional metadata to be assigned to the goal structure.</param>
            <returns>The goal, lifted to a primitive goal structure.</returns>
        </member>
        <member name="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Desire.Goals.IGoal{``0})">
            <inheritdoc cref="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Desire.Goals.IGoal{``0},Aplib.Core.IMetadata)" />
        </member>
        <member name="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Desire.GoalStructures.IGoalStructure{``0},Aplib.Core.IMetadata)">
            <summary>
            Wraps a goal structure into a desire set.
            </summary>
            <param name="goalStructure">
            The goal structure which on its own can function as a desire set. Meaning, the desire set consists of just
            a single goal structure.
            </param>
            <param name="metadata">Optional metadata to be assigned to the desire set.</param>
            <returns>The goal structure, lifted to a desire set.</returns>
        </member>
        <member name="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Desire.GoalStructures.IGoalStructure{``0})">
            <inheritdoc cref="M:Aplib.Core.LiftingExtensionMethods.Lift``1(Aplib.Core.Desire.GoalStructures.IGoalStructure{``0},Aplib.Core.IMetadata)" />
        </member>
        <member name="T:Aplib.Core.Logging.ILoggable">
            <summary>
            An interface that allows defining the structure of loggable objects through a <see cref="T:Aplib.Core.Logging.LogNode"/> tree.
            The only method that needs to be implemented in loggable classes is the <see cref="M:Aplib.Core.Logging.ILoggable.GetLogChildren" /> method;
            the structure of the log tree is generated automatically when calling the <see cref="M:Aplib.Core.Logging.ILoggable.GetLogTree(System.Int32)" /> method.
            </summary>
        </member>
        <member name="M:Aplib.Core.Logging.ILoggable.GetLogChildren">
            <summary>
            Gets the children of the loggable object.
            </summary>
            <returns>The children of the loggable object.</returns>
        </member>
        <member name="M:Aplib.Core.Logging.ILoggable.GetLogTree(System.Int32)">
            <summary>
            Generates a log tree of the loggable object.
            </summary>
            <param name="depth">The depth of this node in the log tree.</param>
            <returns>The root node of the log tree.</returns>
        </member>
        <member name="T:Aplib.Core.Logging.LogNode">
            <summary>
            Represents a node in the log tree.
            </summary>
        </member>
        <member name="P:Aplib.Core.Logging.LogNode.Loggable">
            <summary>
            The loggable object of the node.
            </summary>
        </member>
        <member name="P:Aplib.Core.Logging.LogNode.Depth">
            <summary>
            The depth at which this node resides.
            </summary>
        </member>
        <member name="P:Aplib.Core.Logging.LogNode.Children">
            <summary>
            The children of the node.
            </summary>
        </member>
        <member name="M:Aplib.Core.Logging.LogNode.#ctor(Aplib.Core.Logging.ILoggable,System.Int32,System.Collections.Generic.List{Aplib.Core.Logging.LogNode})">
            <summary>
            Initialize a new <see cref="T:Aplib.Core.Logging.LogNode" /> from a given loggable object,
            the depth, and optionally a list of children.
            </summary>
            <param name="loggable">The loggable object of the node.</param>
            <param name="depth">The depth at which this node resides.</param>
            <param name="children">
            The children of the node.
            It is assumed the children have a correct depth set.
            If omitted, an empty list will be used.
            </param>
        </member>
        <member name="M:Aplib.Core.Logging.LogNode.#ctor(Aplib.Core.Logging.ILoggable,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Aplib.Core.Metadata">
            <summary>
            Data structure to store information about a component which may be useful for debugging or logging.
            </summary>
        </member>
        <member name="P:Aplib.Core.Metadata.Id">
            <inheritdoc />
        </member>
        <member name="P:Aplib.Core.Metadata.Name">
            <inheritdoc />
        </member>
        <member name="P:Aplib.Core.Metadata.Description">
            <inheritdoc />
        </member>
        <member name="M:Aplib.Core.Metadata.#ctor(System.String,System.String)">
            <summary>
            Store information about a BDI cycle component which may be useful for debugging or logging or general
            overviews.
            </summary>
            <param name="name">The name used to display the component.</param>
            <param name="description">The description used to describe the component.</param>
        </member>
        <member name="M:Aplib.Core.Metadata.#ctor(System.Guid,System.String,System.String)">
            <summary>
            Store information about a BDI cycle component which may be useful for debugging or logging or general
            overviews.
            </summary>
            <remarks>This constructor is mainly for testing.</remarks>
            <param name="id">A unique identifier for the component.</param>
            <param name="name">The name used to display the component.</param>
            <param name="description">The description used to describe the component.</param>
        </member>
    </members>
</doc>
